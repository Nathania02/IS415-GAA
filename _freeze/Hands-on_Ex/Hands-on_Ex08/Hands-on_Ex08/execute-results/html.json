{
  "hash": "af75dca0f534c429ffb1c064cdf9fe14",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands-on Ex 8\"\nauthor: \"Nathania Yeo\"\ndate: \"October 16, 2024\"\ndate-modified: \"last-modified\"\nexecute:\n  eval: true\n  echo: true\n  freeze: true\n---\n\n\n# 1.0 Overview\n\nIn this hands-on exercise, I will gain hands-on experience on how to delineate homogeneous region by using geographically referenced multivariate data. There are two major analysis, namely:\n\n-   hierarchical cluster analysis;\n\n-   and spatially constrained cluster analysis.\n\n## 1.1 Learning Outcome\n\nBy the end of this hands-on exercise, I will be able:\n\n-   to convert GIS polygon data into R’s simple feature data.frame by using appropriate functions of sf package of R;\n\n-   to convert simple feature data.frame into R’s SpatialPolygonDataFrame object by using appropriate sf of package of R;\n\n-   to perform custer analysis by using hclust() of Base R;\n\n-   to perform spatially constrained cluster analysis using skater() of Base R;\n\n-   and to visualise the analysis output by using ggplot2 and tmap package.\n\nIn geobusiness and spatial policy, it is a common practice to delineate the market or planning area into homogeneous regions by using multivariate data. In this hands-on exercise, we are interested to delineate Shan State, Myanmar into homogeneous regions by using multiple Information and Communication technology (ICT) measures, namely: Radio, Television, Land line phone, Mobile phone, Computer, and Internet at home.\n\n# 2.0 Setup for Exercise\n\n## 2.1 Data Acquisition\n\nTwo data sets will be used in this study. They are:\n\nMyanmar Township Boundary Data (i.e. myanmar_township_boundaries) : This is a GIS data in ESRI shapefile format. It consists of township boundary information of Myanmar. The spatial data are captured in polygon features.\n\nShan-ICT.csv: This is an extract of The 2014 Myanmar Population and Housing Census Myanmar at the township level.\n\nBoth data sets are download from Myanmar Information Management Unit (MIMU)\n\n## 2.2 R packages\n\nThe R packages needed for this exercise are as follows:\n\n-   Spatial data handling: sf, rgdal and spdep\n\n-   Attribute data handling: tidyverse, especially readr, ggplot2 and dplyr\n\n-   Choropleth mapping: tmap\n\n-   Multivariate data visualisation and analysis: coorplot, ggpubr, and heatmaply\n\n-   Cluster analysis: cluster ClustGeo\n\nThe code chunks below installs and launches these R packages into R environment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(spdep, tmap, sf, ClustGeo, \n               ggpubr, cluster, factoextra, NbClust,\n               heatmaply, corrplot, psych, tidyverse, GGally)\n```\n:::\n\n\n# 3.0 Import Data into R\nSince from the previous hands on exercise, I have already had shan_sf.rds, I will import data from there.\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf <- read_rds(\"data/rds/shan_sf.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 55 features and 22 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 96.15107 ymin: 19.29932 xmax: 101.1699 ymax: 24.15907\nGeodetic CRS:  WGS 84\nFirst 10 features:\n             ST ST_PCODE     DT.x DT_PCODE.x      TS.x  TS_PCODE DT_PCODE.y\n1  Shan (North)   MMR015  Mongmit MMR015D008   Mongmit MMR015017 MMR015D003\n2  Shan (South)   MMR014 Taunggyi MMR014D001   Pindaya MMR014006 MMR014D001\n3  Shan (South)   MMR014 Taunggyi MMR014D001   Ywangan MMR014007 MMR014D001\n4  Shan (South)   MMR014 Taunggyi MMR014D001  Pinlaung MMR014009 MMR014D001\n5  Shan (North)   MMR015  Mongmit MMR015D008    Mabein MMR015018 MMR015D003\n6  Shan (South)   MMR014 Taunggyi MMR014D001     Kalaw MMR014005 MMR014D001\n7  Shan (South)   MMR014 Taunggyi MMR014D001     Pekon MMR014010 MMR014D001\n8  Shan (South)   MMR014 Taunggyi MMR014D001  Lawksawk MMR014008 MMR014D001\n9  Shan (North)   MMR015  Kyaukme MMR015D003 Nawnghkio MMR015013 MMR015D003\n10 Shan (North)   MMR015  Kyaukme MMR015D003   Kyaukme MMR015012 MMR015D003\n       DT.y      TS.y TT_HOUSEHOLDS RADIO    TV LLPHONE MPHONE COMPUTER\n1   Kyaukme   Mongmit         13652  3907  7565     482   3559      166\n2  Taunggyi   Pindaya         17544  7324  8862     348   2849      226\n3  Taunggyi   Ywangan         18348  8890  4781     219   2207       81\n4  Taunggyi  Pinlaung         25504  5908 13816     728   6363      351\n5   Kyaukme    Mabein          8632  3880  6117     628   3389      142\n6  Taunggyi     Kalaw         41341 11607 25285    1739  16900     1225\n7  Taunggyi     Pekon         20084  6399 10762     800   4315      381\n8  Taunggyi  Lawksawk         25957 10048 16353     818   8321      565\n9   Kyaukme Nawnghkio         32224 11257 17657    1239  10409      508\n10  Kyaukme   Kyaukme         28371  5985 17056    1123  10568      878\n   INTERNET RADIO_PR    TV_PR LLPHONE_PR MPHONE_PR COMPUTER_PR INTERNET_PR\n1       321 286.1852 554.1313   35.30618  260.6944    12.15939   23.513038\n2       136 417.4647 505.1300   19.83584  162.3917    12.88190    7.751938\n3       152 484.5215 260.5734   11.93591  120.2856     4.41465    8.284282\n4       737 231.6499 541.7189   28.54454  249.4903    13.76255   28.897428\n5       165 449.4903 708.6423   72.75255  392.6089    16.45042   19.114921\n6      1741 280.7624 611.6204   42.06478  408.7951    29.63160   42.113156\n7       316 318.6118 535.8494   39.83270  214.8476    18.97032   15.733918\n8       556 387.1017 630.0035   31.51366  320.5686    21.76677   21.420041\n9      1216 349.3359 547.9456   38.44960  323.0201    15.76465   37.735849\n10      936 210.9548 601.1773   39.58267  372.4930    30.94709   32.991435\n                         geometry\n1  MULTIPOLYGON (((96.96001 23...\n2  MULTIPOLYGON (((96.7731 21....\n3  MULTIPOLYGON (((96.78483 21...\n4  MULTIPOLYGON (((96.49518 20...\n5  MULTIPOLYGON (((96.66306 24...\n6  MULTIPOLYGON (((96.49518 20...\n7  MULTIPOLYGON (((97.14738 19...\n8  MULTIPOLYGON (((96.94981 22...\n9  MULTIPOLYGON (((96.75648 22...\n10 MULTIPOLYGON (((96.95498 22...\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(shan_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 55\nColumns: 23\n$ ST            <chr> \"Shan (North)\", \"Shan (South)\", \"Shan (South)\", \"Shan (S…\n$ ST_PCODE      <chr> \"MMR015\", \"MMR014\", \"MMR014\", \"MMR014\", \"MMR015\", \"MMR01…\n$ DT.x          <chr> \"Mongmit\", \"Taunggyi\", \"Taunggyi\", \"Taunggyi\", \"Mongmit\"…\n$ DT_PCODE.x    <chr> \"MMR015D008\", \"MMR014D001\", \"MMR014D001\", \"MMR014D001\", …\n$ TS.x          <chr> \"Mongmit\", \"Pindaya\", \"Ywangan\", \"Pinlaung\", \"Mabein\", \"…\n$ TS_PCODE      <chr> \"MMR015017\", \"MMR014006\", \"MMR014007\", \"MMR014009\", \"MMR…\n$ DT_PCODE.y    <chr> \"MMR015D003\", \"MMR014D001\", \"MMR014D001\", \"MMR014D001\", …\n$ DT.y          <chr> \"Kyaukme\", \"Taunggyi\", \"Taunggyi\", \"Taunggyi\", \"Kyaukme\"…\n$ TS.y          <chr> \"Mongmit\", \"Pindaya\", \"Ywangan\", \"Pinlaung\", \"Mabein\", \"…\n$ TT_HOUSEHOLDS <dbl> 13652, 17544, 18348, 25504, 8632, 41341, 20084, 25957, 3…\n$ RADIO         <dbl> 3907, 7324, 8890, 5908, 3880, 11607, 6399, 10048, 11257,…\n$ TV            <dbl> 7565, 8862, 4781, 13816, 6117, 25285, 10762, 16353, 1765…\n$ LLPHONE       <dbl> 482, 348, 219, 728, 628, 1739, 800, 818, 1239, 1123, 310…\n$ MPHONE        <dbl> 3559, 2849, 2207, 6363, 3389, 16900, 4315, 8321, 10409, …\n$ COMPUTER      <dbl> 166, 226, 81, 351, 142, 1225, 381, 565, 508, 878, 2028, …\n$ INTERNET      <dbl> 321, 136, 152, 737, 165, 1741, 316, 556, 1216, 936, 2020…\n$ RADIO_PR      <dbl> 286.18517, 417.46466, 484.52147, 231.64994, 449.49027, 2…\n$ TV_PR         <dbl> 554.1313, 505.1300, 260.5734, 541.7189, 708.6423, 611.62…\n$ LLPHONE_PR    <dbl> 35.306182, 19.835841, 11.935906, 28.544542, 72.752549, 4…\n$ MPHONE_PR     <dbl> 260.69440, 162.39170, 120.28559, 249.49028, 392.60890, 4…\n$ COMPUTER_PR   <dbl> 12.159391, 12.881897, 4.414650, 13.762547, 16.450417, 29…\n$ INTERNET_PR   <dbl> 23.513038, 7.751938, 8.284282, 28.897428, 19.114921, 42.…\n$ geometry      <MULTIPOLYGON [°]> MULTIPOLYGON (((96.96001 23..., MULTIPOLYGO…\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nict <- read_csv (\"data/aspatial/Shan-ICT.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 55 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): District Pcode, District Name, Township Pcode, Township Name\ndbl (7): Total households, Radio, Television, Land line phone, Mobile phone,...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(ict)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n District Pcode     District Name      Township Pcode     Township Name     \n Length:55          Length:55          Length:55          Length:55         \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n Total households     Radio         Television    Land line phone \n Min.   : 3318    Min.   :  115   Min.   :  728   Min.   :  20.0  \n 1st Qu.: 8711    1st Qu.: 1260   1st Qu.: 3744   1st Qu.: 266.5  \n Median :13685    Median : 2497   Median : 6117   Median : 695.0  \n Mean   :18369    Mean   : 4487   Mean   :10183   Mean   : 929.9  \n 3rd Qu.:23471    3rd Qu.: 6192   3rd Qu.:13906   3rd Qu.:1082.5  \n Max.   :82604    Max.   :30176   Max.   :62388   Max.   :6736.0  \n  Mobile phone      Computer      Internet at home\n Min.   :  150   Min.   :  20.0   Min.   :   8.0  \n 1st Qu.: 2037   1st Qu.: 121.0   1st Qu.:  88.0  \n Median : 3559   Median : 244.0   Median : 316.0  \n Mean   : 6470   Mean   : 575.5   Mean   : 760.2  \n 3rd Qu.: 7177   3rd Qu.: 507.0   3rd Qu.: 630.5  \n Max.   :48461   Max.   :6705.0   Max.   :9746.0  \n```\n\n\n:::\n:::\n\n\nThe unit of measurement of the values are number of household. Using these values directly will be bias by the underlying total number of households. In general, the townships with relatively higher total number of households will also have higher number of households owning radio, TV, etc.\n\nIn order to overcome this problem, I will derive the penetration rate of each ICT variable by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nict_derived <- ict %>%\n  mutate(`RADIO_PR` = `Radio`/`Total households`*1000) %>%\n  mutate(`TV_PR` = `Television`/`Total households`*1000) %>%\n  mutate(`LLPHONE_PR` = `Land line phone`/`Total households`*1000) %>%\n  mutate(`MPHONE_PR` = `Mobile phone`/`Total households`*1000) %>%\n  mutate(`COMPUTER_PR` = `Computer`/`Total households`*1000) %>%\n  mutate(`INTERNET_PR` = `Internet at home`/`Total households`*1000) %>%\n  rename(`DT_PCODE` =`District Pcode`,`DT`=`District Name`,\n         `TS_PCODE`=`Township Pcode`, `TS`=`Township Name`,\n         `TT_HOUSEHOLDS`=`Total households`,\n         `RADIO`=`Radio`, `TV`=`Television`, \n         `LLPHONE`=`Land line phone`, `MPHONE`=`Mobile phone`,\n         `COMPUTER`=`Computer`, `INTERNET`=`Internet at home`) \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(ict_derived)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   DT_PCODE              DT              TS_PCODE              TS           \n Length:55          Length:55          Length:55          Length:55         \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n TT_HOUSEHOLDS       RADIO             TV           LLPHONE      \n Min.   : 3318   Min.   :  115   Min.   :  728   Min.   :  20.0  \n 1st Qu.: 8711   1st Qu.: 1260   1st Qu.: 3744   1st Qu.: 266.5  \n Median :13685   Median : 2497   Median : 6117   Median : 695.0  \n Mean   :18369   Mean   : 4487   Mean   :10183   Mean   : 929.9  \n 3rd Qu.:23471   3rd Qu.: 6192   3rd Qu.:13906   3rd Qu.:1082.5  \n Max.   :82604   Max.   :30176   Max.   :62388   Max.   :6736.0  \n     MPHONE         COMPUTER         INTERNET         RADIO_PR     \n Min.   :  150   Min.   :  20.0   Min.   :   8.0   Min.   : 21.05  \n 1st Qu.: 2037   1st Qu.: 121.0   1st Qu.:  88.0   1st Qu.:138.95  \n Median : 3559   Median : 244.0   Median : 316.0   Median :210.95  \n Mean   : 6470   Mean   : 575.5   Mean   : 760.2   Mean   :215.68  \n 3rd Qu.: 7177   3rd Qu.: 507.0   3rd Qu.: 630.5   3rd Qu.:268.07  \n Max.   :48461   Max.   :6705.0   Max.   :9746.0   Max.   :484.52  \n     TV_PR         LLPHONE_PR       MPHONE_PR       COMPUTER_PR    \n Min.   :116.0   Min.   :  2.78   Min.   : 36.42   Min.   : 3.278  \n 1st Qu.:450.2   1st Qu.: 22.84   1st Qu.:190.14   1st Qu.:11.832  \n Median :517.2   Median : 37.59   Median :305.27   Median :18.970  \n Mean   :509.5   Mean   : 51.09   Mean   :314.05   Mean   :24.393  \n 3rd Qu.:606.4   3rd Qu.: 69.72   3rd Qu.:428.43   3rd Qu.:29.897  \n Max.   :842.5   Max.   :181.49   Max.   :735.43   Max.   :92.402  \n  INTERNET_PR     \n Min.   :  1.041  \n 1st Qu.:  8.617  \n Median : 22.829  \n Mean   : 30.644  \n 3rd Qu.: 41.281  \n Max.   :117.985  \n```\n\n\n:::\n:::\n\n\nNotice that six new fields have been added into the data.frame. They are RADIO_PR, TV_PR, LLPHONE_PR, MPHONE_PR, COMPUTER_PR, and INTERNET_PR.\n\nI will include some of the code from the previous Hands-on Ex so that the data used in this Hands-on Ex is accurate.\n\n::: {.cell}\n\n```{.r .cell-code}\ncluster_vars <- shan_sf %>%\n  st_set_geometry(NULL) %>%\n  select(\"TS.x\", \"RADIO_PR\", \"TV_PR\", \"LLPHONE_PR\", \"MPHONE_PR\", \"COMPUTER_PR\")\nhead(cluster_vars,10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        TS.x RADIO_PR    TV_PR LLPHONE_PR MPHONE_PR COMPUTER_PR\n1    Mongmit 286.1852 554.1313   35.30618  260.6944    12.15939\n2    Pindaya 417.4647 505.1300   19.83584  162.3917    12.88190\n3    Ywangan 484.5215 260.5734   11.93591  120.2856     4.41465\n4   Pinlaung 231.6499 541.7189   28.54454  249.4903    13.76255\n5     Mabein 449.4903 708.6423   72.75255  392.6089    16.45042\n6      Kalaw 280.7624 611.6204   42.06478  408.7951    29.63160\n7      Pekon 318.6118 535.8494   39.83270  214.8476    18.97032\n8   Lawksawk 387.1017 630.0035   31.51366  320.5686    21.76677\n9  Nawnghkio 349.3359 547.9456   38.44960  323.0201    15.76465\n10   Kyaukme 210.9548 601.1773   39.58267  372.4930    30.94709\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrow.names(cluster_vars) <- cluster_vars$\"TS.x\"\nhead(cluster_vars,10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               TS.x RADIO_PR    TV_PR LLPHONE_PR MPHONE_PR COMPUTER_PR\nMongmit     Mongmit 286.1852 554.1313   35.30618  260.6944    12.15939\nPindaya     Pindaya 417.4647 505.1300   19.83584  162.3917    12.88190\nYwangan     Ywangan 484.5215 260.5734   11.93591  120.2856     4.41465\nPinlaung   Pinlaung 231.6499 541.7189   28.54454  249.4903    13.76255\nMabein       Mabein 449.4903 708.6423   72.75255  392.6089    16.45042\nKalaw         Kalaw 280.7624 611.6204   42.06478  408.7951    29.63160\nPekon         Pekon 318.6118 535.8494   39.83270  214.8476    18.97032\nLawksawk   Lawksawk 387.1017 630.0035   31.51366  320.5686    21.76677\nNawnghkio Nawnghkio 349.3359 547.9456   38.44960  323.0201    15.76465\nKyaukme     Kyaukme 210.9548 601.1773   39.58267  372.4930    30.94709\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_ict <- select(cluster_vars, c(2:6))\nhead(shan_ict, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          RADIO_PR    TV_PR LLPHONE_PR MPHONE_PR COMPUTER_PR\nMongmit   286.1852 554.1313   35.30618  260.6944    12.15939\nPindaya   417.4647 505.1300   19.83584  162.3917    12.88190\nYwangan   484.5215 260.5734   11.93591  120.2856     4.41465\nPinlaung  231.6499 541.7189   28.54454  249.4903    13.76255\nMabein    449.4903 708.6423   72.75255  392.6089    16.45042\nKalaw     280.7624 611.6204   42.06478  408.7951    29.63160\nPekon     318.6118 535.8494   39.83270  214.8476    18.97032\nLawksawk  387.1017 630.0035   31.51366  320.5686    21.76677\nNawnghkio 349.3359 547.9456   38.44960  323.0201    15.76465\nKyaukme   210.9548 601.1773   39.58267  372.4930    30.94709\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_ict.std <- normalize(shan_ict)\nsummary(shan_ict.std)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    RADIO_PR          TV_PR          LLPHONE_PR       MPHONE_PR     \n Min.   :0.0000   Min.   :0.0000   Min.   :0.0000   Min.   :0.0000  \n 1st Qu.:0.2544   1st Qu.:0.4600   1st Qu.:0.1123   1st Qu.:0.2199  \n Median :0.4097   Median :0.5523   Median :0.1948   Median :0.3846  \n Mean   :0.4199   Mean   :0.5416   Mean   :0.2703   Mean   :0.3972  \n 3rd Qu.:0.5330   3rd Qu.:0.6750   3rd Qu.:0.3746   3rd Qu.:0.5608  \n Max.   :1.0000   Max.   :1.0000   Max.   :1.0000   Max.   :1.0000  \n  COMPUTER_PR     \n Min.   :0.00000  \n 1st Qu.:0.09598  \n Median :0.17607  \n Mean   :0.23692  \n 3rd Qu.:0.29868  \n Max.   :1.00000  \n```\n\n\n:::\n:::\n\n\n# 4.0 Spatially Constrained Clustering: SKATER approach\nIn this section, I will learn how to derive spatially constrained cluster by using skater() method of spdep package.\n\n## 4.1 Converting into SpatialPolygonsDataFrame\nFirst, I will convert shan_sf into SpatialPolygonsDataFrame. This is because SKATER function only support sp obejcts.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sp <- as_Spatial(shan_sf)\n```\n:::\n\n\n## 4.2 Compute Neighbour List\n\n::: {.cell}\n\n```{.r .cell-code}\nshan.nb <- poly2nb(shan_sp)\nsummary(shan.nb)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNeighbour list object:\nNumber of regions: 55 \nNumber of nonzero links: 264 \nPercentage nonzero weights: 8.727273 \nAverage number of links: 4.8 \nLink number distribution:\n\n 2  3  4  5  6  7  8  9 \n 5  9  7 21  4  3  5  1 \n5 least connected regions:\n3 5 7 9 47 with 2 links\n1 most connected region:\n8 with 9 links\n```\n\n\n:::\n:::\n\nWe can plot the neighbours list on shan_sp by using the code chunk below. Since we now can plot the community area boundaries as well, we plot this graph on top of the map. \n\nThe first plot command gives the boundaries. This is followed by the plot of the neighbor list object, with coordinates applied to the original SpatialPolygonDataFrame (Shan state township boundaries) to extract the centroids of the polygons. These are used as the nodes for the graph representation. We also set the color to blue and specify add=TRUE to plot the network on top of the boundaries.\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords <- st_coordinates(st_centroid(st_geometry(shan_sf)))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(st_geometry(shan_sf), \n     border=grey(.5))\nplot(shan.nb,\n     coords, \n     col=\"blue\", \n     add=TRUE)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\nNote that if you plot the network first and then the boundaries, some of the areas will be clipped. This is because the plotting area is determined by the characteristics of the first plot. In this example, because the boundary map extends further than the graph, we plot it first.\n\n## 4.3 Compute minimum spanning tree\n### 4.3.1 Calculating edge costs\nNext, nbcosts() of spdep package is used to compute the cost of each edge. It is the distance between it nodes. This function compute this distance using a data.frame with observations vector in each node.\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_ict <- read_rds(\"data/rds/shan_ict.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlcosts <- nbcosts(shan.nb, shan_ict)\n```\n:::\n\n\nFor each observation, this gives the pairwise dissimilarity between its values on the five variables and the values for the neighbouring observation (from the neighbour list). Basically, this is the notion of a generalised weight for a spatial weights matrix.\n\nNext, We will incorporate these costs into a weights object in the same way as we did in the calculation of inverse of distance weights. In other words, we convert the neighbour list to a list weights object by specifying the just computed lcosts as the weights.\n\nIn order to achieve this, nb2listw() of spdep package is used as shown in the code chunk below.\n\nNote that we specify the style as B to make sure the cost values are not row-standardised.\n\n::: {.cell}\n\n```{.r .cell-code}\nshan.w <- nb2listw(shan.nb, lcosts, style=\"B\")\nsummary(shan.w)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 55 \nNumber of nonzero links: 264 \nPercentage nonzero weights: 8.727273 \nAverage number of links: 4.8 \nLink number distribution:\n\n 2  3  4  5  6  7  8  9 \n 5  9  7 21  4  3  5  1 \n5 least connected regions:\n3 5 7 9 47 with 2 links\n1 most connected region:\n8 with 9 links\n\nWeights style: B \nWeights constants summary:\n   n   nn       S0       S1        S2\nB 55 3025 76267.65 58260785 522016004\n```\n\n\n:::\n:::\n\n\n## 4.4 Compute minimum spanning tree\nThe minimum spanning tree is computed by mean of the mstree() of spdep package as shown in the code chunk below.\n\n::: {.cell}\n\n```{.r .cell-code}\nshan.mst <- mstree(shan.w)\n```\n:::\n\n\nAfter computing the MST, we can check its class and dimension by using the code chunk below.\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(shan.mst)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"mst\"    \"matrix\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(shan.mst)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 54  3\n```\n\n\n:::\n:::\n\nNote that the dimension is 54 and not 55. This is because the minimum spanning tree consists on n-1 edges (links) in order to traverse all the nodes.\n\nWe can display the content of shan.mst by using head() as shown in the code chunk below.\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(shan.mst)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]      [,3]\n[1,]   51   30 108.37735\n[2,]   30   27  57.60801\n[3,]   27   41  78.29342\n[4,]   51   38 146.66661\n[5,]   41   39 162.80878\n[6,]   39   19  79.41836\n```\n\n\n:::\n:::\n\nThe plot method for the MST include a way to show the observation numbers of the nodes in addition to the edge. As before, we plot this together with the township boundaries. We can see how the initial neighbour list is simplified to just one edge connecting each of the nodes, while passing through all the nodes.\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(st_geometry(shan_sf), \n                 border=gray(.5))\nplot.mst(shan.mst, \n         coords, \n         col=\"blue\", \n         cex.lab=0.7, \n         cex.circles=0.005, \n         add=TRUE)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n## 4.5 Compute spatially constrained clusters using SKATER method\nThe code chunk below compute the spatially constrained cluster using skater() of spdep package.\n\n::: {.cell}\n\n```{.r .cell-code}\nclust6 <- spdep::skater(edges = shan.mst[,1:2], \n                 data = shan_ict, \n                 method = \"euclidean\", \n                 ncuts = 5)\n```\n:::\n\n\nThe skater() takes three mandatory arguments: - the first two columns of the MST matrix (i.e. not the cost), - the data matrix (to update the costs as units are being grouped), and - the number of cuts. Note: It is set to one less than the number of clusters. So, the value specified is not the number of clusters, but the number of cuts in the graph, one less than the number of clusters.\n\nThe result of the skater() is an object of class skater. We can examine its contents by using the code chunk below.\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(clust6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 8\n $ groups      : num [1:55] 3 3 6 3 3 3 3 3 3 3 ...\n $ edges.groups:List of 6\n  ..$ :List of 3\n  .. ..$ node: num [1:18] 47 27 53 38 42 15 41 51 43 32 ...\n  .. ..$ edge: num [1:17, 1:3] 53 15 42 38 41 51 15 27 15 43 ...\n  .. ..$ ssw : num 3759\n  ..$ :List of 3\n  .. ..$ node: num [1:22] 13 48 54 55 45 37 34 16 25 52 ...\n  .. ..$ edge: num [1:21, 1:3] 48 55 54 37 34 16 45 25 13 13 ...\n  .. ..$ ssw : num 3423\n  ..$ :List of 3\n  .. ..$ node: num [1:11] 2 6 8 1 36 4 10 9 46 5 ...\n  .. ..$ edge: num [1:10, 1:3] 6 1 8 36 4 6 8 10 10 9 ...\n  .. ..$ ssw : num 1458\n  ..$ :List of 3\n  .. ..$ node: num [1:2] 44 20\n  .. ..$ edge: num [1, 1:3] 44 20 95\n  .. ..$ ssw : num 95\n  ..$ :List of 3\n  .. ..$ node: num 23\n  .. ..$ edge: num[0 , 1:3] \n  .. ..$ ssw : num 0\n  ..$ :List of 3\n  .. ..$ node: num 3\n  .. ..$ edge: num[0 , 1:3] \n  .. ..$ ssw : num 0\n $ not.prune   : NULL\n $ candidates  : int [1:6] 1 2 3 4 5 6\n $ ssto        : num 12613\n $ ssw         : num [1:6] 12613 10977 9962 9540 9123 ...\n $ crit        : num [1:2] 1 Inf\n $ vec.crit    : num [1:55] 1 1 1 1 1 1 1 1 1 1 ...\n - attr(*, \"class\")= chr \"skater\"\n```\n\n\n:::\n:::\n\nThe most interesting component of this list structure is the groups vector containing the labels of the cluster to which each observation belongs (as before, the label itself is arbitary). This is followed by a detailed summary for each of the clusters in the edges.groups list. Sum of squares measures are given as ssto for the total and ssw to show the effect of each of the cuts on the overall criterion.\n\nWe can check the cluster assignment by using the conde chunk below.\n\n::: {.cell}\n\n```{.r .cell-code}\nccs6 <- clust6$groups\nccs6\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 3 3 6 3 3 3 3 3 3 3 1 2 2 2 1 2 2 2 1 4 2 1 5 2 2 2 1 2 1 1 2 1 1 2 2 3 2 1\n[39] 1 1 1 1 1 4 2 3 1 2 2 2 1 2 1 2 2\n```\n\n\n:::\n:::\n\nWe can find out how many observations are in each cluster by means of the table command. Parenthetially, we can also find this as the dimension of each vector in the lists contained in edges.groups. For example, the first list has node with dimension 12, which is also the number of observations in the first cluster.\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(ccs6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nccs6\n 1  2  3  4  5  6 \n18 22 11  2  1  1 \n```\n\n\n:::\n:::\n\n\nLastly, we can also plot the pruned tree that shows the five clusters on top of the townshop area.\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(st_geometry(shan_sf), \n     border=gray(.5))\nplot(clust6, \n     coords, \n     cex.lab=.7,\n     groups.colors=c(\"red\",\"green\",\"blue\", \"brown\", \"pink\"),\n     cex.circles=0.005, \n     add=TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1], coords[id2,\n: \"add\" is not a graphical parameter\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1], coords[id2,\n: \"add\" is not a graphical parameter\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1], coords[id2,\n: \"add\" is not a graphical parameter\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1], coords[id2,\n: \"add\" is not a graphical parameter\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n\n## 4.6 Visualising clusters in choropleth map\n\n::: {.cell}\n\n```{.r .cell-code}\nproxmat <- dist(shan_ict, method = 'euclidean')\nhclust_ward <- hclust(proxmat, method = 'ward.D')\ngroups <- as.factor(cutree(hclust_ward, k=6))\nshan_sf_cluster <- cbind(shan_sf, as.matrix(groups)) %>% rename(`CLUSTER`=`as.matrix.groups.`)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngroups_mat <- as.matrix(clust6$groups)\nshan_sf_spatialcluster <- cbind(shan_sf_cluster, as.factor(groups_mat)) %>%\n  rename(`SP_CLUSTER`=`as.factor.groups_mat.`)\nqtm(shan_sf_spatialcluster, \"SP_CLUSTER\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n:::\n\n\nFor easy comparison, it will be better to place both the hierarchical clustering and spatially constrained hierarchical clustering maps next to each other.\n\n::: {.cell}\n\n```{.r .cell-code}\nhclust.map <- qtm(shan_sf_cluster,\n                  \"CLUSTER\") + \n  tm_borders(alpha = 0.5) \n\nshclust.map <- qtm(shan_sf_spatialcluster,\n                   \"SP_CLUSTER\") + \n  tm_borders(alpha = 0.5) \n\ntmap_arrange(hclust.map, shclust.map,\n             asp=NA, ncol=2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: One tm layer group has duplicated layer types, which are omitted. To\ndraw multiple layers of the same type, use multiple layer groups (i.e. specify\ntm_shape prior to each of them).\nWarning: One tm layer group has duplicated layer types, which are omitted. To\ndraw multiple layers of the same type, use multiple layer groups (i.e. specify\ntm_shape prior to each of them).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n\n# 5.0 Spatially constrained clustering: ClustGeo Method\n## 5.1 A short note about ClustGeo package\nClustGeo package is an R package specially designed to support the need of performing spatially constrained cluster analysis. More specifically, it provides a Ward-like hierarchical clustering algorithm called hclustgeo() including spatial/geographical constraints.\n\nIn the nutshell, the algorithm uses two dissimilarity matrices D0 and D1 along with a mixing parameter alpha, whereby the value of alpha must be a real number between [0, 1]. D0 can be non-Euclidean and the weights of the observations can be non-uniform. It gives the dissimilarities in the attribute/clustering variable space. D1, on the other hand, gives the dissimilarities in the constraint space. The criterion minimised at each stage is a convex combination of the homogeneity criterion calculated with D0 and the homogeneity criterion calculated with D1.\n\nThe idea is then to determine a value of alpha which increases the spatial contiguity without deteriorating too much the quality of the solution based on the variables of interest. This need is supported by a function called choicealpha().\n\n## 5.2 Ward-like hierarchical clustering: ClustGeo\nClustGeo package provides function called hclustgeo() to perform a typical Ward-like hierarchical clustering just like hclust() you learned in previous section.\n\nTo perform non-spatially constrained hierarchical clustering, we only need to provide the function a dissimilarity matrix as shown in the code chunk below.\n\n::: {.cell}\n\n```{.r .cell-code}\nnongeo_cluster <- hclustgeo(proxmat)\nplot(nongeo_cluster, cex = 0.5)\nrect.hclust(nongeo_cluster, \n            k = 6, \n            border = 2:5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n:::\n\n\nNote that the dissimilarity matrix must be an object of class dist, i.e. an object obtained with the function dist(). For sample code chunk, please refer to 5.7.6 Computing proximity matrix from the previous Hands-on Exercise.\n\n### 5.2.1 Map the clusters formed\n\n::: {.cell}\n\n```{.r .cell-code}\ngroups <- as.factor(cutree(nongeo_cluster, k=6))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf_ngeo_cluster <- cbind(shan_sf, as.matrix(groups)) %>%\n  rename(`CLUSTER` = `as.matrix.groups.`)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nqtm(shan_sf_ngeo_cluster, \"CLUSTER\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-36-1.png){width=672}\n:::\n:::\n\n\n## 5.3 Spatially Constrained Hierarchical Clustering\nBefore we can performed spatially constrained hierarchical clustering, a spatial distance matrix will be derived by using st_distance() of sf package.\n\n::: {.cell}\n\n```{.r .cell-code}\ndist <- st_distance(shan_sf, shan_sf)\ndistmat <- as.dist(dist)\n```\n:::\n\nNotice that as.dist() is used to convert the data frame into matrix.\n\nNext, choicealpha() will be used to determine a suitable value for the mixing parameter alpha as shown in the code chunk below.\n\n::: {.cell}\n\n```{.r .cell-code}\ncr <- choicealpha(proxmat, distmat, range.alpha = seq(0, 1, 0.1), K=6, graph = TRUE)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-38-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-38-2.png){width=672}\n:::\n:::\n\n\nWith reference to the graphs above, alpha = 0.2 will be used as shown in the code chunk below.\n\n::: {.cell}\n\n```{.r .cell-code}\nclustG <- hclustgeo(proxmat, distmat, alpha = 0.2)\n```\n:::\n\n\nNext, cutree() is used to derive the cluster object.\n\n::: {.cell}\n\n```{.r .cell-code}\ngroups <- as.factor(cutree(clustG, k=6))\n```\n:::\n\n\nWe will then join back the group list with shan_sf polygon feature data frame by using the code chunk below.\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf_Gcluster <- cbind(shan_sf, as.matrix(groups)) %>% rename(`CLUSTER` = `as.matrix.groups.`)\n```\n:::\n\n\nWe can now plot the map of the newly delineated spatially constrained clusters.\n\n::: {.cell}\n\n```{.r .cell-code}\nqtm(shan_sf_Gcluster, \"CLUSTER\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-42-1.png){width=672}\n:::\n:::\n\n\n# 6.0 Visual Interpretation of Clusters\n## 6.1 Visualising individual clustering variable\nCode chunk below is used to reveal the distribution of a clustering variable (i.e RADIO_PR) by cluster.\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = shan_sf_ngeo_cluster,\n       aes(x = CLUSTER, y = RADIO_PR)) +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-43-1.png){width=672}\n:::\n:::\n\nThe boxplot reveals Cluster 3 displays the highest mean Radio Ownership Per Thousand Household. This is followed by Cluster 2, 1, 4, 6 and 5.\n\n## 6.2 Multivariate Visualisation\nPast studies shown that parallel coordinate plot can be used to reveal clustering variables by cluster very effectively. In the code chunk below, ggparcoord() of GGally package\n\n::: {.cell}\n\n```{.r .cell-code}\nggparcoord(data = shan_sf_ngeo_cluster, \n           columns = c(17:21), \n           scale = \"globalminmax\",\n           alphaLines = 0.2,\n           boxplot = TRUE, \n           title = \"Multiple Parallel Coordinates Plots of ICT Variables by Cluster\") +\n  facet_grid(~ CLUSTER) + \n  theme(axis.text.x = element_text(angle = 30))\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-44-1.png){width=672}\n:::\n:::\n\nThe parallel coordinate plot above reveals that households in Cluster 4 townships tend to own the highest number of TV and mobile-phone. On the other hand, households in Cluster 5 tends to own the lowest of all the five ICT.\n\nNote that the scale argument of ggparcoor() provide several methods to scale the clustering variables. They are:\n\nstd: univariately, subtract mean and divide by standard deviation.\nrobust: univariately, subtract median and divide by median absolute deviation.\nuniminmax: univariately, scale so the minimum of the variable is zero, and the maximum is one.\nglobalminmax: no scaling is done; the range of the graphs is defined by the global minimum and the global maximum.\ncenter: use uniminmax to standardize vertical height, then center each variable at a value specified by the scaleSummary param.\ncenterObs: use uniminmax to standardize vertical height, then center each variable at the value of the observation specified by the centerObsID param\nThere is no one best scaling method to use. You should explore them and select the one that best meet your analysis need.\n\nLast but not least, we can also compute the summary statistics such as mean, median, sd, etc to complement the visual interpretation.\n\nIn the code chunk below, group_by() and summarise() of dplyr are used to derive mean values of the clustering variables.\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf_ngeo_cluster %>% \n  st_set_geometry(NULL) %>%\n  group_by(CLUSTER) %>%\n  summarise(mean_RADIO_PR = mean(RADIO_PR),\n            mean_TV_PR = mean(TV_PR),\n            mean_LLPHONE_PR = mean(LLPHONE_PR),\n            mean_MPHONE_PR = mean(MPHONE_PR),\n            mean_COMPUTER_PR = mean(COMPUTER_PR))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 6\n  CLUSTER mean_RADIO_PR mean_TV_PR mean_LLPHONE_PR mean_MPHONE_PR\n  <chr>           <dbl>      <dbl>           <dbl>          <dbl>\n1 1               221.        521.            44.2           246.\n2 2               237.        402.            23.9           134.\n3 3               300.        611.            52.2           392.\n4 4               196.        744.            99.0           651.\n5 5               124.        224.            38.0           132.\n6 6                98.6       499.            74.5           468.\n# ℹ 1 more variable: mean_COMPUTER_PR <dbl>\n```\n\n\n:::\n:::\n",
    "supporting": [
      "Hands-on_Ex08_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}